package com.walmart.fraudengine.dao;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;

import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.walmart.fraudengine.model.BaseEntity;
import com.walmart.fraudengine.util.FraudCheckConst;

@Repository
public abstract class GenericDaoJpa implements GenericDao {

	protected static final String QUERY_DOT = ".";

	protected static final String ORDER_BY = " order by ";

	protected static final String DEFAULT_ORDER_COLUMN = " 1 ";

	protected static final String SOFT_DELETE = "softDelete";

	protected static final String STATUS = "status";

	@PersistenceContext(unitName = "fraudPersistenceUnit")
	protected EntityManager em;

	/**
	 * In this method, the passed entity is persisted first, then the flush
	 * method is invoked. This forces the EntityManager to flush its cache to
	 * the database. The state of the cached entities will be written to the
	 * database with one or more INSERT statements ï¿½ but not committed yet.
	 * Since our primary key is generated by the database, the flush forces the
	 * database to compute the primary key. After the flush invocation, the
	 * entity is refreshed so the state of the entity is overwritten with the
	 * state in the database. This behavior is required to force the JPA
	 * provider to generate and provide the primary key to the entity instance.
	 * 
	 * @see com.walmart.fraudengine.dao.GenericDao#create(com.walmart.fraudengine.model.BaseEntity)
	 */
	@Override
	@Transactional
	public <T extends BaseEntity> T create(T entity) {

		em.persist(entity);
		em.flush();
		em.refresh(entity);
		return entity;
	}

	/**
	 * @see com.walmart.fraudengine.dao.GenericDao#find(java.lang.Object,
	 *      java.lang.Class)
	 */
	@Override
	@Transactional(readOnly = true, propagation = Propagation.SUPPORTS)
	public <T extends BaseEntity> T find(Object entityPk, Class<T> entityClass) {

		return (T) this.em.find(entityClass, entityPk);
	}

	/**
	 * @see com.walmart.fraudengine.dao.GenericDao#merge(com.walmart.fraudengine.model.BaseEntity)
	 */
	@Override
	@Transactional
	public <T extends BaseEntity> T merge(T t) {

		return (T) this.em.merge(t);
	}

	/**
	 * @see com.walmart.fraudengine.dao.GenericDao#delete(com.walmart.fraudengine.model.BaseEntity)
	 */
	@Override
	@Transactional
	public <T extends BaseEntity> void delete(T t) {

		t.setSoftDelete(FraudCheckConst.INCLUDE_SOFT_DELETE);
	}

	@Override
	@Transactional
	public <T extends BaseEntity> List<T> findByNamedQuery(Class<T> entityClass, String namedQuery) {

		return findByNamedQuery(entityClass, namedQuery, null);
	}

	@SuppressWarnings("unchecked")
	@Override
	@Transactional
	public <T extends BaseEntity> List<T> findByNamedQuery(Class<T> entityClass, String namedQuery, Map<String, Object> parameters) {

		final Query query = this.em.createNamedQuery(entityClass.getSimpleName() + QUERY_DOT + namedQuery);
		if (parameters != null) {
			for (Entry<String, Object> param : parameters.entrySet()) {
				query.setParameter(param.getKey(), param.getValue());
			}
		}
		final List<T> resultList = query.getResultList();
		if (resultList == null)
			return new LinkedList<T>();
		return resultList;
	}
}